#!/usr/bin/env node

// This code was 100% generated by an LLM. Use at your own peril.

const http = require('http');
const net = require('net');
const fs = require('fs');
const url = require('url');

// Simple argument parsing
function parseArgs() {
	const args = process.argv.slice(2); // Remove node and script path
	let fd = null;
	let whitelistPath = null;

	for (let i = 0; i < args.length; i++) {
		switch (args[i]) {
			case '-f':
			case '--fd':
				i++;
				if (i >= args.length) {
					console.error('Error: Missing value for file descriptor');
					process.exit(1);
				}
				fd = parseInt(args[i], 10);
				if (isNaN(fd) || fd < 0) {
					console.error('Error: File descriptor must be a non-negative integer');
					process.exit(1);
				}
				break;

			case '-w':
			case '--whitelist':
				i++;
				if (i >= args.length) {
					console.error('Error: Missing path for whitelist');
					process.exit(1);
				}
				whitelistPath = args[i];
				if (whitelistPath !== '-' && !fs.existsSync(whitelistPath)) {
					console.error(`Error: Whitelist file ${whitelistPath} does not exist`);
					process.exit(1);
				}
				break;

			case '-h':
			case '--help':
				console.log(`
Usage: ./http_proxy_fd.js -f <fd> -w <whitelist-file>

Options:
	-f, --fd <number>					TCP file descriptor number to use for listening
	-w, --whitelist <file>		 Path to whitelist file (use - for stdin)
	-h, --help								 Show this help message

Examples:
	./http_proxy_fd.js -f 3 -w whitelist.txt						# Use whitelist from file
	echo "example.com" | ./http_proxy_fd.js -f 3 -w -	 # Read whitelist from stdin

Whitelist Format:
	domain.com							# Allow domain.com on ports 80,443
	domain.com:8080				 # Allow domain.com on port 8080
	*.example.com					# Allow all subdomains of example.com on ports 80,443
	192.168.1.1:80,443		 # Allow IPv4 address on specific ports
	[::1]:8080						 # Allow IPv6 address on specific port
`);
				process.exit(0);
		}
	}

	if (fd === null || whitelistPath === null) {
		console.error('Error: Both -f and -w options are required');
		process.exit(1);
	}

	return { fd, whitelistPath };
}

// Parse an address entry from the whitelist
function parseAddressEntry(entry) {
	entry = entry.trim();
	let host, ports;

	// Handle IPv6 addresses
	if (entry.startsWith('[')) {
		const closeBracket = entry.indexOf(']');
		if (closeBracket === -1) return null;
		
		host = entry.substring(1, closeBracket);
		if (!isValidIPv6(host)) return null;
		
		if (entry.length > closeBracket + 1) {
			if (entry[closeBracket + 1] !== ':') return null;
			ports = entry.substring(closeBracket + 2).split(',').map(p => parseInt(p, 10));
		}
	} else {
		// Handle domain names and IPv4 addresses
		const [hostPart, portPart] = entry.split(':');
		host = hostPart;
		if (portPart) {
			ports = portPart.split(',').map(p => parseInt(p, 10));
		}
	}

	// Validate ports if specified
	if (ports) {
		if (!ports.every(p => !isNaN(p) && p > 0 && p < 65536)) return null;
	} else {
		ports = [80, 443]; // Default ports if none specified
	}

	return { host, ports };
}

// Validate IPv6 address
function isValidIPv6(ip) {
	try {
		return net.isIPv6(ip);
	} catch {
		return false;
	}
}

// Load and parse whitelist
async function loadWhitelist(whitelistPath) {
	let whitelistContent;
	
	if (whitelistPath === '-') {
		whitelistContent = await new Promise((resolve) => {
			let data = '';
			process.stdin.setEncoding('utf8');
			process.stdin.on('data', chunk => data += chunk);
			process.stdin.on('end', () => resolve(data));
		});
	} else {
		whitelistContent = await fs.promises.readFile(whitelistPath, 'utf8');
	}
	
	const whitelist = new Map();
	
	whitelistContent
		.split('\n')
		.map(line => line.trim())
		.filter(line => line && !line.startsWith('#'))
		.forEach(line => {
			const entry = parseAddressEntry(line);
			if (entry) {
				whitelist.set(entry.host, entry.ports);
			} else {
				console.error(`Invalid whitelist entry: ${line}`);
			}
		});
	
	return whitelist;
}

// Check if host matches a wildcard pattern
function matchesWildcard(pattern, host) {
	if (!pattern.startsWith('*.')) return false;
	const suffix = pattern.slice(2);
	return host === suffix || host.endsWith('.' + suffix);
}

// Check if host:port combination is allowed
function isDestinationAllowed(host, port, whitelist) {
	// First check for exact match
	if (whitelist.has(host)) {
		return whitelist.get(host).includes(port);
	}
	
	// Then check for wildcard matches
	for (const [pattern, ports] of whitelist.entries()) {
		if (pattern.startsWith('*.') && matchesWildcard(pattern, host)) {
			return ports.includes(port);
		}
	}
	
	return false;
}

async function main() {
	const args = parseArgs();
	const whitelist = await loadWhitelist(args.whitelistPath);

	const server = http.createServer();

	server.on('connect', (req, clientSocket, head) => {
		let hostname, port;

		// Parse the hostname and port from the CONNECT request
		if (req.url.startsWith('[')) {
			// IPv6 address
			const closeBracket = req.url.indexOf(']');
			if (closeBracket === -1) {
				clientSocket.write('HTTP/1.1 400 Bad Request\r\n\r\n');
				clientSocket.end();
				return;
			}
			hostname = req.url.substring(1, closeBracket);
			port = parseInt(req.url.substring(closeBracket + 2)) || 443;
		} else {
			// Domain name or IPv4 address
			const parts = req.url.split(':');
			hostname = parts[0];
			port = parseInt(parts[1]) || 443;
		}

		if (!isDestinationAllowed(hostname, port, whitelist)) {
			console.error(`Denied CONNECT to ${hostname}:${port}`);
			clientSocket.write('HTTP/1.1 403 Forbidden\r\n\r\n');
			clientSocket.end();
			return;
		}

		const serverSocket = net.connect(port, hostname, () => {
			clientSocket.write('HTTP/1.1 200 Connection Established\r\n\r\n');
			serverSocket.write(head);
			serverSocket.pipe(clientSocket);
			clientSocket.pipe(serverSocket);
		});

		serverSocket.on('error', (err) => {
			console.error(`Error connecting to ${hostname}:${port}:`, err);
			clientSocket.end();
		});

		clientSocket.on('error', (err) => {
			// Only log if it's not a normal connection reset
			if (err.code !== 'ECONNRESET') {
				console.error('Client socket error:', err);
			}
			serverSocket.end();
		});
	});

	server.on('request', (req, res) => {
		// Check if this is a proxy request or direct request
		if (!req.url.startsWith('http://') && !req.url.startsWith('https://')) {
			res.writeHead(400);
			res.end('This is a proxy server. Please use appropriate proxy settings in your client.');
			return;
		}

		const parsedUrl = url.parse(req.url);
		if (!parsedUrl || !parsedUrl.hostname) {
			res.writeHead(400);
			res.end('Invalid proxy request');
			return;
		}

		let hostname, port;

		// Parse the hostname and port from the request URL
		if (parsedUrl.hostname.startsWith('[')) {
			// IPv6 address
			const closeBracket = parsedUrl.hostname.indexOf(']');
			if (closeBracket === -1) {
				res.writeHead(400);
				res.end('Bad Request');
				return;
			}
			hostname = parsedUrl.hostname.substring(1, closeBracket);
			port = parseInt(parsedUrl.hostname.substring(closeBracket + 2)) || 80;
		} else {
			// Domain name or IPv4 address
			hostname = parsedUrl.hostname;
			port = parseInt(parsedUrl.port) || 80;
		}

		if (!isDestinationAllowed(hostname, port, whitelist)) {
			console.error(`Denied request to ${hostname}:${port}`);
			res.writeHead(403);
			res.end('Forbidden');
			return;
		}

		const options = {
			hostname: hostname,
			port: port,
			path: parsedUrl.path,
			method: req.method,
			headers: req.headers
		};

		const proxyReq = http.request(options, (proxyRes) => {
			res.writeHead(proxyRes.statusCode, proxyRes.headers);
			proxyReq.on('error', (err) => {
				if (!res.headersSent) {
					res.writeHead(502);
					res.end('Bad Gateway');
				}
				console.error('Error during proxy response:', err);
			});
			proxyRes.pipe(res);
		});

		proxyReq.on('error', (err) => {
			console.error('Error proxying request:', err);
			if (!res.headersSent) {
				res.writeHead(502);
				res.end('Bad Gateway');
			}
		});

		req.on('error', (err) => {
			// Only log if it's not a normal connection reset
			if (err.code !== 'ECONNRESET') {
				console.error('Request error:', err);
			}
			if (!res.headersSent) {
				res.writeHead(500);
				res.end('Internal Server Error');
			}
		});

		req.pipe(proxyReq);
	});

	server.listen({ fd: args.fd }, () => {
		console.log(`Proxy server listening on fd ${args.fd}`);
	});

	server.on('error', (err) => {
		console.error('Server error:', err);
		process.exit(1);
	});
}

main().catch(err => {
	console.error('Fatal error:', err);
	process.exit(1);
});
